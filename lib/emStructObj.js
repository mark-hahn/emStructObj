// Generated by CoffeeScript 1.6.2
/*
	file: emStructObj\emStructObj.coffee
    source code for emStructObj project
    
    convert emscripten C struct data to/from javascript objects
    to be used as debug calls in code or from javascript console
    include it in emscripten as pre-add file
    creates global window.emStruct function
    
    usage:
    	// addr: number, heap byte addr
    	// name: string, name of struct at addr
    	// count: number, record count (defaults to 10)
    	emStruct(addr, name, count)
    
		// example: emStruct(100, 'pgm_globals', 5);
*/


(function() {
  var addrInc, chkStruct, defLine, emObjToStruct, emStructObj, emdef, error, exports, format, haveError, isPointer, line, member, memberName, memberType, ptrMatch, struct, structName, structs, typeDef, word, wordIdx, words, _, _i, _j, _k, _len, _len1, _len2, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if ((typeof exports !== "undefined" && exports !== null) && (typeof module !== "undefined" && module !== null) && module.exports) {
    _ = require('underscore');
    _.mixin(require('underscore.string').exports());
    emdef = require('emStructDefs');
  } else {
    _ = window._;
    _.mixin(_.str.exports());
    exports = window;
    emdef = emDefinitions;
  }

  structs = {};

  struct = [];

  structName = '';

  haveError = false;

  error = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    console.log.apply(console, ['emStructObj error:'].concat(__slice.call(args)));
    return haveError = true;
  };

  chkStruct = function() {
    if (structName) {
      structs[structName] = struct;
      return struct = [];
    }
  };

  _ref = emdef.structDefs.split('\n');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    defLine = _ref[_i];
    if ((line = _.trim(defLine)) === '') {
      continue;
    }
    if (_.startsWith(line, 'struct ')) {
      chkStruct();
      structName = _.trim(line.slice(7));
      continue;
    }
    if (!structName) {
      error('struct name missing --', defLine);
      break;
    }
    words = (_.trim(line.split(';')[0])).split(/\s/);
    memberType = memberName = isPointer = null;
    wordIdx = 0;
    for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
      word = words[_j];
      if ((ptrMatch = /^\*(.*)$/.exec(word))) {
        isPointer = true;
        memberType = 'ptr';
        word = ptrMatch[1];
      }
      word = _.trim(word);
      if (word === '' || __indexOf.call(emdef.noiseWords, word) >= 0) {
        continue;
      }
      wordIdx++;
      if (isPointer) {
        wordIdx++;
      }
      switch (wordIdx) {
        case 1:
          memberType = word;
          typeDef = emdef.typeDefs[memberType];
          if (!typeDef) {
            error('unknown type', memberType, '--', defLine);
          }
          break;
        case 2:
          memberName = word;
          for (_k = 0, _len2 = struct.length; _k < _len2; _k++) {
            member = struct[_k];
            if (member[1] === memberName) {
              error('duplicate member in', structName, '--', defLine);
            }
          }
          struct.push([memberType, memberName]);
          break;
        default:
          error('more than 2 words in member def --', defLine);
      }
      if (haveError) {
        break;
      }
    }
    if (haveError) {
      break;
    }
  }

  if (haveError) {
    return;
  }

  chkStruct();

  addrInc = function(size) {
    switch (size) {
      case 'i8':
        return 1;
      case 'i16':
        return 2;
      case 'i32':
      case 'float':
        return 4;
      case 'i64':
      case 'double':
        return 8;
    }
  };

  format = function(type, val, logFormat) {
    switch (type.format) {
      case 'hex':
        if (val < 10 || !logFormat) {
          return val;
        } else {
          return '0x' + val.toString(16);
        }
      case 'str':
        return Pointer_stringify(val);
      case 'strw':
        return UTF16ToString(val);
      default:
        return val;
    }
  };

  exports.emStructObj = emStructObj = exports.emStructToObj = function(addr, name, arrayLen, logFormat) {
    var idx, memberTypeDef, obj, results, type, typeInc, val, _l, _len3, _len4, _m, _n, _ref1;

    if (typeof addr !== 'number' || addr < 0 || addr !== Math.floor(addr)) {
      error('address must be a positive integer', addr);
      return;
    }
    if ((type = emdef.typeDefs[name]) && !(typeInc = addrInc(type.size))) {
      error('invalid size', type.size, 'in type', name);
      return;
    }
    if (!type) {
      if (!(struct = structs[name])) {
        error('struct', name, 'is not defined');
        return;
      }
      for (_l = 0, _len3 = struct.length; _l < _len3; _l++) {
        member = struct[_l];
        memberType = member[0], memberName = member[1];
        if (!(memberTypeDef = emdef.typeDefs[memberType]) || !addrInc(memberTypeDef.size)) {
          error('invalid size', memberTypeDef.size, 'in member', memberName);
          return;
        }
      }
    }
    results = [];
    for (idx = _m = 0, _ref1 = arrayLen != null ? arrayLen : 1; 0 <= _ref1 ? _m < _ref1 : _m > _ref1; idx = 0 <= _ref1 ? ++_m : --_m) {
      if (type) {
        val = getValue(addr, type.size);
        results.push(format(type, val, logFormat));
        addr += typeInc;
        continue;
      }
      obj = {};
      for (_n = 0, _len4 = struct.length; _n < _len4; _n++) {
        member = struct[_n];
        memberType = member[0], memberName = member[1];
        if (structs[memberName]) {
          val = getValue(addr, typeDefs.ptr.size);
          obj[memberName] = emStructObj(val, memberName);
          addr += addrInc(typeDefs.ptr.size);
          continue;
        }
        memberTypeDef = emdef.typeDefs[memberType];
        val = getValue(addr, memberTypeDef.size);
        obj[memberName] = format(memberTypeDef, val, logFormat);
        addr += addrInc(memberTypeDef.size);
      }
      results.push(obj);
    }
    if (arrayLen) {
      return results;
    } else {
      return results[0];
    }
  };

  if (emdef.useShortcuts) {
    exports.emso = exports.ems2o = function(addr, name, arrayLen, logFormat) {
      if (arrayLen == null) {
        arrayLen = 1;
      }
      if (logFormat == null) {
        logFormat = true;
      }
      return emStructObj(addr, name, arrayLen, logFormat);
    };
  }

  console.log(emdef.typeDefs, structs);

  exports.emObjToStruct = emObjToStruct = function(obj, addr, name) {
    var buf, bufSize, char, charSize, memberTypeDef, nestedMember, nestedStruct, newBufs, objArray, objVal, size, strAddr, type, typeInc, val, _l, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p;

    objArray = (_.isArray(obj) ? obj : [obj]);
    if (typeof addr !== 'number' || addr < 0 || addr !== Math.floor(addr)) {
      error('emObjToStruct: address must be a positive integer', addr);
      return false;
    }
    if ((type = emdef.typeDefs[name]) && !(typeInc = addrInc(type.size))) {
      error('invalid size', type.size, 'in type', name);
      return false;
    }
    if (!type) {
      if (!(struct = structs[name])) {
        error('emObjToStruct: struct', name, 'is not defined', {
          objArray: objArray,
          addr: addr,
          name: name
        });
        return false;
      }
      for (_l = 0, _len3 = struct.length; _l < _len3; _l++) {
        member = struct[_l];
        memberType = member[0], memberName = member[1];
        if (!(memberTypeDef = emdef.typeDefs[memberType]) || !addrInc(memberTypeDef.size)) {
          error('invalid size', memberTypeDef.size, 'in member', memberName);
          return false;
        }
      }
    }
    newBufs = [];
    for (_m = 0, _len4 = objArray.length; _m < _len4; _m++) {
      obj = objArray[_m];
      if (type) {
        setValue(addr, obj, type.size);
        addr += typeInc;
        continue;
      }
      for (_n = 0, _len5 = struct.length; _n < _len5; _n++) {
        member = struct[_n];
        memberType = member[0], memberName = member[1];
        if ((nestedStruct = structs[memberName])) {
          bufSize = 0;
          for (_o = 0, _len6 = struct.length; _o < _len6; _o++) {
            nestedMember = struct[_o];
            bufSize += addrInc(emdef.typeDefs[nestedMember[0]].size);
          }
          buf = _malloc(bufSize);
          newBufs.push(buf);
          bufs.concat(emObjToStruct(obj[memberName], buf, memberType));
          setValue(addr, buf, emdef.typeDefs.ptr.size);
          addr += addrInc(emdef.typeDefs.ptr.size);
          continue;
        }
        memberTypeDef = emdef.typeDefs[memberType];
        format = memberTypeDef.format;
        size = memberTypeDef.size;
        objVal = obj[memberName];
        if (typeof objVal === string) {
          if (objVal.slice(0, 2).toLowerCase() === '0x' && format === 'hex') {
            val = parseInt(objVal.slice(2), 16);
          } else {
            charSize = (format === 'strw' ? 2 : 1);
            size = (charSize === 1 ? 'i8' : 'i16');
            buf = _malloc((objVal.length + 1) * charSize);
            newBufs.push(buf);
            strAddr = buf;
            for (_p = 0, _len7 = objVal.length; _p < _len7; _p++) {
              char = objVal[_p];
              setValue(strAddr, char, size);
              strAddr += charSize;
            }
            setValue(strAddr, 0, size);
            val = buf;
            size = emdef.typeDefs.ptr.size;
          }
        }
        setValue(addr, val, size);
        addr += addrInc(size);
      }
    }
    return newBufs;
  };

  if (emdef.useShortcuts) {
    exports.emo2s = emObjToStruct;
  }

}).call(this);

/*
//@ sourceMappingURL=emStructObj.map
*/
