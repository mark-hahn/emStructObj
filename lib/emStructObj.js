// Generated by CoffeeScript 1.6.2
/*
	file: emStructObj\emStructObj.coffee
    source code for emStructObj project
    
    convert emscripten C struct data to/from javascript objects
    to be used as debug calls in code or from javascript console
    include it in emscripten as pre-add file
    creates global window.emStruct function
    
    usage:
    	// addr: number, heap byte addr
    	// name: string, name of struct at addr
    	// count: number, record count (defaults to 10)
    	emStruct(addr, name, count)
    
		// example: emStruct(100, 'pgm_globals', 5);
*/


(function() {
  var chkStruct, defLine, emdef, error, exports, haveError, isPointer, line, member, memberName, memberType, ptrMatch, struct, structName, structs, typeDef, word, wordIdx, words, _, _i, _j, _k, _len, _len1, _len2, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if ((typeof exports !== "undefined" && exports !== null) && (typeof module !== "undefined" && module !== null) && module.exports) {
    _ = require('underscore');
    _.mixin(require('underscore.string').exports());
    emdef = require('emStructDefs');
  } else {
    _ = window._;
    _.mixin(_.str.exports());
    exports = window;
    emdef = emDefinitions;
  }

  structs = {};

  struct = [];

  structName = '';

  haveError = false;

  error = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    console.log.apply(console, ['emStructObj error:'].concat(__slice.call(args)));
    return haveError = true;
  };

  chkStruct = function() {
    if (structName) {
      structs[structName] = struct;
      return struct = [];
    }
  };

  _ref = emdef.structDefs.split('\n');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    defLine = _ref[_i];
    if ((line = _.trim(defLine)) === '') {
      continue;
    }
    if (_.startsWith(line, 'struct ')) {
      chkStruct();
      structName = _.trim(line.slice(7));
      continue;
    }
    if (!structName) {
      error('struct name missing --', defLine);
      break;
    }
    words = (_.trim(line.split(';')[0])).split(/\s/);
    memberType = memberName = isPointer = null;
    wordIdx = 0;
    for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
      word = words[_j];
      if ((ptrMatch = /^\*(.*)$/.exec(word))) {
        isPointer = true;
        memberType = 'ptr';
        word = ptrMatch[1];
      }
      word = _.trim(word);
      if (word === '' || __indexOf.call(emdef.noiseWords, word) >= 0) {
        continue;
      }
      wordIdx++;
      if (isPointer) {
        wordIdx++;
      }
      switch (wordIdx) {
        case 1:
          memberType = word;
          typeDef = emdef.typeDefs[memberType];
          if (!typeDef) {
            error('unknown type', memberType, '--', defLine);
          }
          break;
        case 2:
          memberName = word;
          for (_k = 0, _len2 = struct.length; _k < _len2; _k++) {
            member = struct[_k];
            if (member[1] === memberName) {
              error('duplicate member in', structName, '--', defLine);
            }
          }
          struct.push([memberType, memberName]);
          break;
        default:
          error('more than 2 words in member def --', defLine);
      }
      if (haveError) {
        break;
      }
    }
    if (haveError) {
      break;
    }
  }

  if (haveError) {
    return;
  }

  chkStruct();

  console.log(structs);

  debugger;

  exports.emStructObj = exports.emStructToObj = function(addr, name, arrayLen) {
    if (arrayLen == null) {
      arrayLen = 1;
    }
  };

  if (emdef.useShortcuts) {
    exports.emso = exports.emStructObj;
  }

  exports.emObjToStruct = function(obj, addr, name, arrayLen) {
    if (arrayLen == null) {
      arrayLen = 1;
    }
  };

  if (emdef.useShortcuts) {
    exports.emo2s = exports.emObjToStruct;
  }

}).call(this);

/*
//@ sourceMappingURL=emStructObj.map
*/
